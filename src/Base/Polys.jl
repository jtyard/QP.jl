###############
# Polynomial rings and their generators in some convenient forms for computing with polynomial functions 
# on matrices and projective spaces
###############

using Oscar

export MatrixPolynomialRing, VariableMatrix, MatrixGradedPolynomialRing, QQXgraded
export QQX, Xij, TrX, TrX2, QQXhom, QQXt
export QQzw,wj,zj, ABN, AN, BN, monomials_of_degree, laplacian

###############
# Matrix polynomials 
###############

# Generators 

function MatrixPolynomialRing(F,N::Int,X::Union{AbstractString, Char, Symbol} = "X")
    PolynomialRing(F,[string(X,"_{",i,",",j,"}") for i in 0:N-1 for j in 0:N-1],cached=true)[1]
end

function VariableMatrix(F,N::Int,X::Union{AbstractString, Char, Symbol} = "X")
    R = MatrixPolynomialRing(F,N,X)
    matrix(R,N,N,gens(R))
end

@memoize function MatrixGradedPolynomialRing(F::AbstractAlgebra.Ring,N::Int,X::Union{AbstractString, Char, Symbol} = "X")
    GradedPolynomialRing(F,[string(X,"_{",i,",",j,"}") for i in 0:N-1 for j in 0:N-1],)[1] 
end

#####
# "Legacy"
#####
function QQX(N; graded = false) 
    graded ? MatrixGradedPolynomialRing(QQ,N) : MatrixPolynomialRing(QQ,N)
end


# Okay for now but a more general definition allowing other names and instances ultimately needed
Xij(i::Union{Int,nmod},j::Union{Int,nmod},N::Int) = gens(QQX(N))[1 + (Int(j) % N) + N*(Int(i) % N)]
Xij(j::nmod_mat) = Xij(j[1],j[2],Int(characteristic(base_ring(j))))
Xij(N::Int) = matrix(QQX(N),[[Xij(i,j,N) for j =0:N-1] for i =0:N-1])


# Ring homomorphism taking Xij(N) -> Y when Y is an N x N matrix
QQXhom(Y) = hom(QQX(nrows(Y)),QQX(nrows(Y)),vec(transpose(Y)))
QQXt(N::Int) = QQXhom(transpose(Xij(N)))


TrX(N::Int) = sum([Xij(i,i,N) for i = 0:N-1])
TrX2(N::Int) = sum([Xij(i,j,N)*Xij(j,i,N) for i = 0:N-1 for j = 0:N-1])

# The 2x2 minors cut out the rank < 2 matrices
minors(N::Int) = [Xij(i,k,N)*Xij(j,l,N)-Xij(i,l,N)*Xij(j,k,N) for i in 0:N-2 for j in i+1:N-1 for k in 0:N-2 for l in k+1:N-1];

# The irrelevant ideal generated by the matrix units
QQXp(N::Int; graded = false) = ideal(QQX(N,graded = graded),gens(QQX(N)))


#####################
# z zbar coordinates 
#####################

@memoize function QQzw(N::Int; graded = false)
    graded ? GradedPolynomialRing(QQ,vcat([string("z",i) for i in 0:N-1],[string("w",i) for i in 0:N-1]), vcat([ [1,0] for i in 1:N],[[0,1] for i in 1:N]))[1] : PolynomialRing(QQ,vcat([string("z",i) for i in 0:N-1],[string("w",i) for i in 0:N-1]))[1]
end

# Assuming for now input is of the type QQzw - can/should be generalized
function monomials_of_degree(R::AbstractAlgebra.Ring,n::Union{Int,fmpz})
    Rnn, to_R = homogeneous_component(R,[n,n])
    [to_R(f) for f in gens(Rnn)]
end

function zj(j::nmod) 
    N = Int(characteristic(parent(j)))
    j = Int(j)
    gens(QQzw(N))[1 + (j % N)]
end

function wj(j::nmod) 
    N = Int(characteristic(parent(j)))
    j = Int(j)
    gens(QQzw(N))[1 + N + (j % N)]
end

function ABN(N)
    A = [gpX(N) 0*gpX(N); 0*gpX(N) gpX(N)]
    B = [gpZ(N) 0*gpZ(N); 0*gpZ(N) gpZ(N)]
    matrix_group([A,B])
end

AN(N) = gens(ABN(N))[1]
BN(N) = gens(ABN(N))[2]




laplacian(f) = sum([derivative(derivative(f,zj(a)),wj(a)) for a in ZN(ZZ(length(gens(parent(f)))//2))])

