###############
# Polynomial rings and their generators in some convenient forms for computing with polynomial functions 
# on matrices and projective spaces
###############

export MatrixPolynomialRing, VariableMatrix, MatrixGradedPolynomialRing, QQXgraded
export QQX, Xij, TrX, TrX2, QQXhom, QQXt
export QQzw,wj,zj

###############
# Polynomials 
###############

# Generators 

function MatrixPolynomialRing(F,N::Int,X::Union{AbstractString, Char, Symbol} = "X")
    PolynomialRing(F,[string(X,"_{",i,",",j,"}") for i in 0:N-1 for j in 0:N-1],cached=true)[1]
end

function VariableMatrix(F,N::Int,X::Union{AbstractString, Char, Symbol} = "X")
    R = MatrixPolynomialRing(F,N,X)
    matrix(R,N,N,gens(R))
end

@cache function MatrixGradedPolynomialRing(F,N::Int,X::Union{AbstractString, Char, Symbol} = "X")
    GradedPolynomialRing(F,[string(X,"_{",i,",",j,"}") for i in 0:N-1 for j in 0:N-1])[1]
end

#####
# "Legacy"
#####
# Or should this be cached?
QQX(N) = MatrixPolynomialRing(QQ,N)

QQXgraded(N) = MatrixGradedPolynomialRing(QQ,N)

# Not sure what Oscar can do with these at the moment (i.e. with Proj). 
@cache function QQzw(N::Int)
    GradedPolynomialRing(QQ,vcat([string("z",i) for i in 0:N-1],[string("w",i) for i in 0:N-1]))[1]
end

# Okay for now but a more general definition allowing other names and instances ultimately needed
Xij(i::Union{Int,nmod},j::Union{Int,nmod},N::Int) = gens(QQX(N))[1 + (Int(j) % N) + N*(Int(i) % N)]
Xij(j::nmod_mat) = Xij(j[1],j[2],Int(characteristic(base_ring(j))))
Xij(N::Int) = matrix(QQX(N),[[Xij(i,j,N) for j =0:N-1] for i =0:N-1])


# Ring homomorphism taking Xij(N) -> Y when Y is an N x N matrix
QQXhom(Y) = hom(QQX(nrows(Y)),QQX(nrows(Y)),vec(transpose(Y)))
QQXt(N::Int) = QQXhom(transpose(Xij(N)))


TrX(N::Int) = sum([Xij(i,i,N) for i = 0:N-1])
TrX2(N::Int) = sum([Xij(i,j,N)*Xij(j,i,N) for i = 0:N-1 for j = 0:N-1])

# The 2x2 minors cut out the rank < 2 matrices
minors(N::Int) = [Xij(i,k,N)*Xij(j,l,N)-Xij(i,l,N)*Xij(j,k,N) for i in 0:N-2 for j in i+1:N-1 for k in 0:N-2 for l in k+1:N-1];

# The irrelevant ideal generated by the matrix units
QQXp(N::Int) = ideal(QQX(N),gens(QQX(N)))




# Not sure what Oscar can do with these at the moment (i.e. with Proj). 
@cache function QQzw(N::Int)
    GradedPolynomialRing(QQ,vcat([string("z",i) for i in 0:N-1],[string("w",i) for i in 0:N-1]))[1]
end

function zj(j::nmod) 
    N = Int(characteristic(parent(j)))
    j = Int(j)
    gens(QQzw(N))[1 + (j % N)]
end

function wj(j::nmod) 
    N = Int(characteristic(parent(j)))
    j = Int(j)
    gens(QQzw(N))[1 + N + (j % N)]
end

