###############
# Multivariate polynomial rings of matrix entries
###############

using Oscar
using Unicode

import Oscar.gen, Oscar.matrix, Oscar.minors, Oscar.irrelevant_ideal, Oscar.saturation

export matrix_polynomial_ring, MatPolyRing, MatPolyIdeal


export Iminors, Ihplus, Ihminus, Itorus, dwork_modulus, dwork_polynomial



# export print_with_subscripts, display_with_subscripts, latex_representation

struct MatPolyRing{T, R<:Ring, S<:MPolyRing} <: Ring
    R::R
    N::Int
    S::S
    Sgr::MPolyDecRing

    function MatPolyRing(R::Ring, N::Int, vars::Vector{String})
        S, _ = polynomial_ring(R, vars)
        T = Oscar.elem_type(S)
        new{T, typeof(R), typeof(S)}(R, N, S, grade(S)[1])
    end
end

# Constructor
function MatPolyRing(F::Ring, N::Int; X::Union{AbstractString, Char, Symbol} = "X")
    vars = [string(X, "_{", i, ",", j, "}") for i in 0:N-1 for j in 0:N-1]
    MatPolyRing(F, N, vars)
end

# Alternate constructor that accepts a symbol for the variable name
#function MatPolyRing(F::Ring, N::Int; X::Symbol = :X)
#    MatPolyRing(F, N, X=string(X))
#end


matrix_polynomial_ring(F::Ring, N::Int; X::Union{AbstractString, Char} = "X") = MatPolyRing(F, N, X=X)
matrix_polynomial_ring(F::Ring, N::Int, X::Symbol) = MatPolyRing(F, N, X=X)



## Display methods

function Base.show(io::IO, R::MatPolyRing)
    X = split(string(R.S.S[1]),'_')[1]
    print(io, "Polynomial ring in $(R.N)×$(R.N) variables $(X)_{⋅,⋅} over ", R.R)
end


# Helper function to convert subscript numbers
function to_subscript(n::Int)
    subscript_digits = ['₀', '₁', '₂', '₃', '₄', '₅', '₆', '₇', '₈', '₉']
    return join(subscript_digits[digit(n, i) + 1] for i in reverse(1:ndigits(n)))
end



# Implement necessary methods
Oscar.base_ring(R::MatPolyRing) = R.R
Oscar.ngens(R::MatPolyRing) = R.N^2
Oscar.gens(R::MatPolyRing) = gens(R.S)
Oscar.gen(R::MatPolyRing, i::Int) = gen(R.S, i)

# Add matrix-specific methods
function gen(R::MatPolyRing)
    matrix(R.S, R.N, R.N, gens(R.S))
end

function Oscar.gen(R::MatPolyRing, i::Int, j::Int)
    gen(R.S, (i % R.N)*R.N + (j % R.N) + 1)
end

# Element type
Oscar.elem_type(::Type{<:MatPolyRing{T}}) where {T} = T

# Define zero and one for the ring
function Oscar.zero(R::MatPolyRing)
    return matrix(R.S, R.N, R.N, [zero(R.S) for _ in 1:R.N^2])
end

function Oscar.one(R::MatPolyRing)
    return matrix(R.S, R.N, R.N, [i == j ? one(R.S) : zero(R.S) for i in 1:R.N for j in 1:R.N])
end

# Conversion method
function (R::MatPolyRing)(a)
    return R.S(a)
end






##############
# MatPolyIdeal interface
##############
#  https://docs.oscar-system.org/stable/AlgebraicGeometry/FrameWorks/ArchitectureOfAffineSchemes/

# MatPolyIdeal definition
struct MatPolyIdeal{T, R<:MatPolyRing} <: Ideal{T}
    R::R
    gens::Vector{T}
    I::MPolyIdeal

    function MatPolyIdeal(R::MatPolyRing, g::Union{RingElem, RingElement, Integer}...)
        T = Oscar.elem_type(R.S)
        oscar_gens = [R.S(R(f)) for f in g]
        I = ideal(R.S, oscar_gens)
        new{T, typeof(R)}(R, [R(f) for f in g], I)
    end

    function MatPolyIdeal(R::MatPolyRing, g::Vector)
        T = Oscar.elem_type(R.S)
        oscar_gens = [R.S(R(f)) for f in g]
        I = ideal(R.S, oscar_gens)
        new{T, typeof(R)}(R, [R(f) for f in g], I)
    end
end

# Ideal constructors
function Oscar.ideal(R::MatPolyRing, g::Union{RingElem, RingElement, Integer}...)
    MatPolyIdeal(R, g...)
end

function Oscar.ideal(R::MatPolyRing, g::Vector)
    MatPolyIdeal(R, g)
end

# Quotient ring constructor
function Oscar.quo(R::MatPolyRing, I::MatPolyIdeal)
    Q, f = quo(R.S, I.I)
    return Q, f
end

# Ideal membership test
function Base.in(f::RingElem, I::MatPolyIdeal)
    return I.R.S(f) in I.I
end

# Generators
Oscar.gens(I::MatPolyIdeal) = I.gens

# Coordinates
function Oscar.coordinates(f::RingElem, I::MatPolyIdeal)
    return Oscar.coordinates(I.R.S(f), I.I)
end

# Show method for MatPolyIdeal
function Base.show(io::IO, I::MatPolyIdeal)
    print(io, "Ideal in ", I.R, " generated by ", I.gens)
end

# Implement necessary methods for Ideal interface
Oscar.base_ring(I::MatPolyIdeal) = I.R
Oscar.ngens(I::MatPolyIdeal) = length(I.gens)
Oscar.gen(I::MatPolyIdeal, i::Int) = I.gens[i]


# Sum of ideals
function Base.:+(I::MatPolyIdeal, J::MatPolyIdeal)
    @assert I.R == J.R "Ideals must be in the same ring"
    K = I.I + J.I  # Using Oscar's implementation
    return MatPolyIdeal(I.R, gens(K))
end

# Product of ideals
function Base.:*(I::MatPolyIdeal, J::MatPolyIdeal)
    @assert I.R == J.R "Ideals must be in the same ring"
    K = I.I * J.I  # Using Oscar's implementation
    return MatPolyIdeal(I.R, gens(K))
end

# Intersection of ideals
function Oscar.intersect(I::MatPolyIdeal, J::MatPolyIdeal)
    @assert I.R == J.R "Ideals must be in the same ring"
    K = intersect(I.I, J.I)  # Using Oscar's implementation
    return MatPolyIdeal(I.R, gens(K))
end

# Quotient of ideals
function Oscar.quotient(I::MatPolyIdeal, J::MatPolyIdeal)
    @assert I.R == J.R "Ideals must be in the same ring"
    K = quotient(I.I, J.I)  # Using Oscar's implementation
    return MatPolyIdeal(I.R, gens(K))
end

# Saturation of an ideal
function Oscar.saturation(I::MatPolyIdeal, J::MatPolyIdeal)
    @assert I.R == J.R "Ideals must be in the same ring"
    K = saturation(I.I, J.I)  # Using Oscar's implementation
    return MatPolyIdeal(I.R, gens(K))
end

# Radical of an ideal
function Oscar.radical(I::MatPolyIdeal)
    K = radical(I.I)  # Using Oscar's implementation
    return MatPolyIdeal(I.R, gens(K))
end

# Primary decomposition of an ideal
function Oscar.primary_decomposition(I::MatPolyIdeal)
    decomp = primary_decomposition(I.I)  # Using Oscar's implementation
    return [MatPolyIdeal(I.R, gens(J)) for J in decomp]
end

# Equality test for ideals
function Base.:(==)(I::MatPolyIdeal, J::MatPolyIdeal)
    return I.R == J.R && I.I == J.I
end

# Subset test for ideals
function Base.issubset(I::MatPolyIdeal, J::MatPolyIdeal)
    @assert I.R == J.R "Ideals must be in the same ring"
    return issubset(I.I, J.I)
end




#######################################################################
#######################################################################
# Useful polynomials 
#######################################################################
#######################################################################


function fij(S::MatPolyRing,j1::Union{Int,zzModRingElem},j2::Union{Int,zzModRingElem}) 
    X(i,j) = gen(S,i,j)
    sum([X(a,a+j1)*X(a+j1+j2,a+j2) for a=0:S.N-1])
end

function fij(S::MatPolyRing,j::zzModMatrix) 
    fij(S,j[1],j[2])
end

function fplus(S::MatPolyRing,j1::Union{Int,zzModRingElem},j2::Union{Int,zzModRingElem}) 
    (1//2)*(fij(S,j1,j2) + fij(S,j2,j1))
end

function fplus(S::MatPolyRing,j::zzModMatrix) 
    fplus(S,j[1],j[2])
end

function fminus(S::MatPolyRing,j1::Union{Int,zzModRingElem},j2::Union{Int,zzModRingElem}) 
    (1//2)*(fij(S,j1,j2) - fij(S,j2,j1))
end

function fminus(S::MatPolyRing,j::zzModMatrix) 
    fminus(S,j[1],j[2])
end

## Projecting onto harmonic subspace

function hij(S::MatPolyRing,j1::Union{Int,zzModRingElem},j2::Union{Int,zzModRingElem}) 
    X = gen(S) 
    c = (1//2)*(tr(X^2) + tr(X)^2)*(1//(S.N+1))
    fij(S,j1,j2) - S.Sgr((Int(j1) == 0 ? 1 : 0) + (Int(j2) == 0 ? 0 : 1))*c
end

function hij(S::MatPolyRing,j::zzModMatrix) 
    hij(S,j[1],j[2])
end

function hplus(S::MatPolyRing,j1::Union{Int,zzModRingElem},j2::Union{Int,zzModRingElem})
    X = gen(S) 
    c = (1//2)*(tr(X^2) + tr(X)^2)*(1//(S.N+1))
    fplus(S,j1,j2) - ((Int(j1) == 0 ? 1 : 0) + (Int(j2) == 0 ? 1 : 0))*c
end

function hplus(S::MatPolyRing,j::zzModMatrix) 
    hplus(S,j[1],j[2])
end

function hminus(S::MatPolyRing,j1::Union{Int,zzModRingElem},j2::Union{Int,zzModRingElem}) 
    X = gen(S) 
    c = (1//2)*(tr(X^2) - tr(X)^2)*(1//(S.N-1))
    fminus(S,j1,j2) - ((Int(j1) == 0) || (Int(j2) == 0) ? 1 : 0)*c
end

function hminus(S::MatPolyRing,j::zzModMatrix) 
    hminus(S,j[1],j[2])
end


## Laplacian 
# Should eventually replace Laplacian and laplacian from Polys.jl
function laplacian(S::MatPolyRing,f)
    sum([derivative(f,gen(S,a,a)) for a in 0:S.N-1])
end

## Ideals
## To make life easier for now they all live in the graded ring S.Sgr
## i.e. so they are not actually of type MatPolyIdeal
## Might need a MatDecPolyIdeal to do it properly...

function Ihplus(S::MatPolyRing)
    ideal(S.Sgr,[hplus(S,j1,j2) for j1 in 0:S.N-1 for j2 in 0:j1])
end

Ihminus(S::MatPolyRing) = ideal(S.Sgr,[hminus(S,i,j) for i in 0:S.N-1 for j in 0:i if i != j])

function Iminors(S::MatPolyRing,k) 
    ideal(S.Sgr,minors(gen(S),k))
end

Ireal(S::MatPolyRing) = ideal(S.Sgr,[gen(S,i,j) - gen(S,j,i) for i in 0:S.N-1 for j in 0:i if i != j])

function Itorus(S::MatPolyRing,t::zzModMatrix) 
    N = S.N
    ideal(S.Sgr,[gen(S,j1,j2) - gen(S,Int((ZN(N)[j1 j2]*t)[1]),Int((ZN(N)[j1 j2]*t)[2])) for j1 in 0:S.N-1 for j2 in 0:S.N-1])
end

# Ideal generated by action of cyclic group <t> on generators.  
function Icyclic(S::MatPolyRing,t::zzModMatrix) 
    N = S.N
    ideal(S.Sgr,[gen(S,ZN(N)[j1 j2]) - gen(S,ZN(N)[j1 j2]*t) for j1 in 0:S.N-1 for j2 in 0:S.N-1])
end

#function Oscar.irrelevant_ideal(R::MPolyRing)
#    ideal(gens(R))
#end

Ic(R::MatPolyRing) = ideal(R.Sgr,[gen(R,j1,j2) - gen(R,j2,j1) for j1 in 0:R.N-1 for j2 in 0:R.N-1 if j1 < j2] )
Icc(R::MatPolyRing) = ideal(R.Sgr, [gen(R,j1,j2) - gen(R,-j2,-j1) for j1 in 0:R.N-1 for j2 in 0:R.N-1] )
Itr1(R::MatPolyRing) = ideal(R,[tr(gen(R)) - 1])
Itr0(R::MatPolyRing) = ideal(R.Sgr,[tr(gen(R))])
IT(R::MatPolyRing, a::Int) = ideal(R.Sgr, [gen(R)(j1,j2) - gen(R,a*j1,a*j2) for j1 in 0:R.N-1 for j2 in 0:R.N-1] )



function irrelevant_ideal(S::MatPolyRing)
    irrelevant_ideal(S.Sgr)
end


function dwork_polynomial(P::MatPolyRing,mu,mubar)
    X = gen(P)
    N = P.N
    
    ss = sum(X[i,j]^N for i in 1:N for j in 1:N) # (sum z_i^N)(sum w_i^N)
    pp = prod(X[i,i] for i in 1:N) # (prod z_i^N)(prod w_i^N)
    sp = sum(prod(X[i,j] for j in 1:N) for i in 1:N) # (sum z_i^N)(prod w_i^N)
    ps = sum(prod(X[j,i] for j in 1:N) for i in 1:N) # (prod z_i^N)(sum w_i^N)
    
    ss - N*(ps*mu + sp*mubar) + N^2*mu*mubar*pp
end